{
    "type": "bundle",
    "id": "bundle--e13a7b9b-1a1a-43d2-9244-9f0e298d9f72",
    "objects": [
        {
            "type": "attack-pattern",
            "spec_version": "2.1",
            "id": "attack-pattern--7178682e-9591-4ebe-a24e-25b7b2ee07a5",
            "created_by_ref": "identity--b73c59c1-8560-449a-b8d0-c2ce0533c5bf",
            "created": "2020-02-05T20:28:15.188Z",
            "modified": "2020-02-05T20:28:15.188Z",
            "name": "Debugger Detection",
            "description": "Malware detects whether it's being executed inside a debugger. If so, conditional execution selects a benign execution path.",
            "kill_chain_phases": [
                {
                    "kill_chain_name": "mitre-mbc",
                    "phase_name": "anti-behavioral-analysis"
                }
            ],
            "external_references": [
                {
                    "source_name": "mitre-mbc",
                    "url": "https://github.com/MBCProject/mbc-markdown/blob/master/anti-behavioral-analysis/detect-debugger.md",
                    "external_id": "M0001"
                },
                {
                    "source_name": "external_source",
                    "description": "Alexander Antukh, \"Anti-debugging Techniques Cheat Sheet,\" 19 January 2015.",
                    "url": "http://antukh.com/blog/2015/01/19/malware-techniques-cheat-sheet."
                },
                {
                    "source_name": "external_source",
                    "description": "Joshua Cannell, Malwarebytes Labs, \"Five Anti-Analysis Tricks that sometimes Fool Analysts,\" 31 March 2016.",
                    "url": "https://blog.malwarebytes.com/threat-analysis/2014/09/five-anti-debugging-tricks-that-sometimes-fool-analysts."
                },
                {
                    "source_name": "external_source",
                    "description": "Peter Ferrie, \"The 'Ultimate' Anti-Debugging Reference,\" 4 May 2011.",
                    "url": "https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf."
                },
                {
                    "source_name": "external_source",
                    "description": "Atif Mushtaq, FireEye, \"The Dead Giveaways of VM-Aware Malware,\" 27 January 2011.",
                    "url": "https://www.fireeye.com/blog/threat-research/2011/01/the-dead-giveaways-of-vm-aware-malware.html."
                },
                {
                    "source_name": "external_source",
                    "description": "Ayoub Faouzi (LordNoteworthy), Al-Khaser v0.79.",
                    "url": "https://github.com/LordNoteworthy/al-khaser"
                },
                {
                    "source_name": "external_source",
                    "description": "Nicolas Falliere, Symantec, \"Windows Anti-Debug Reference,\" 11 September 2007.",
                    "url": "https://www.symantec.com/connect/articles/windows-anti-debug-reference."
                },
                {
                    "source_name": "external_source",
                    "description": "Anti Debugging Tricks, Al-Khaser.",
                    "url": "https://github.com/LordNoteworthy/al-khaser/wiki/Anti-Debugging-Tricks"
                }
            ],
            "object_marking_refs": [
                "marking-definition--093b6375-cd45-4aa3-8f91-6a03ddd7a3d3"
            ],
            "x_mitre_methods": [
                {
                    "definition": "module bounds based [[7]](#7)",
                    "name": "API Hook Detection"
                },
                {
                    "definition": "The kernel32!CheckRemoteDebuggerPresent function calls NtQueryInformationProcess with ProcessInformationClass parameter set to 7 (ProcessDebugPort constant).",
                    "name": "CheckRemoteDebuggerPresent"
                },
                {
                    "definition": "(NtClose); If an invalid handle is passed to the CloseHandle function and a debugger is present, then an EXCEPTION_INVALID_HANDLE (0xC0000008) exception will be raised. [[7]](#7)",
                    "name": "CloseHandle"
                },
                {
                    "definition": "Malware may detect a debugger by its artifact (window title, device driver, exports, etc.).",
                    "name": "Debugger Artifacts"
                },
                {
                    "definition": "(SEH/GetThreadContext); Debug registers will indicate the presence of a debugger. See [[7]](#7) for details.",
                    "name": "Hardware Breakpoints"
                },
                {
                    "definition": "If int 0x2d is mishandled by the debugger, it can cause a single-byte instruction to be inadvertently skipped, which can be detected by malware.",
                    "name": "Interrupt 0x2d"
                },
                {
                    "definition": "[[7]](#7)",
                    "name": "Interrupt 1"
                },
                {
                    "definition": "The kernel32!IsDebuggerPresent API function call checks the PEB BeingDebugged flag to see if the calling process is being debugged. It returns 1 if the process is being debugged, 0 otherwise. This is one of the most common ways of debugger detection.",
                    "name": "IsDebuggerPresent"
                },
                {
                    "definition": "(PAGE_GUARD); Guard pages trigger an exception the first time they are accessed and can be used to detect a debugger. See [[7]](#7) for details.",
                    "name": "Memory Breakpoints"
                },
                {
                    "definition": "[[7]](#7)",
                    "name": "Memory Write Watching"
                },
                {
                    "definition": "Malware may spawn a monitoring thread to detect tampering, breakpoints, etc.",
                    "name": "Monitoring Thread"
                },
                {
                    "definition": "Calling NtQueryInformationProcess with its ProcessInformationClass parameter set to 0x07 (ProcessDebugPort constant) will cause the system to set ProcessInformation to -1 if the process is being debugged. Calling with ProcessInformationClass set to 0x0E (ProcessDebugFlags) or 0x11 (ProcessDebugObject) are used similarly. Testing \"ProcessDebugPort\" is equivalent to using the kernel32!CheckRemoteDebuggerPresent API call (see next method).",
                    "name": "NtQueryInformationProcess"
                },
                {
                    "definition": "The ObjectTypeInformation and ObjectAllTypesInformation flags are checked for debugger detection.",
                    "name": "NtQueryObject"
                },
                {
                    "definition": "Calling this API with a fake class length or thread handle can indicate whether it is hooked. After calling NtSetInformationThread properly, the HideThreadFromDebugger flag is checked with the NtQueryInformationThread API. [[7]](#7)",
                    "name": "NtSetInformationThread"
                },
                {
                    "definition": "[[7]](#7)",
                    "name": "NtYieldExecution/SwitchToThread"
                },
                {
                    "definition": "(GetLastError); The OutputDebugString function will demonstrate different behavior depending whether or not a debugger is present. See [[7]](#7) for details.",
                    "name": "OutputDebugString"
                },
                {
                    "definition": "[[7]](#7)",
                    "name": "Page Exception Breakpoint Detection"
                },
                {
                    "definition": "(Explorer.exe); Executing an application by a debugger will result in the parent process being the debugger process rather than the shell process (Explorer.exe) or the command line. Malware checks its parent process; if it's not explorer.exe, it's assumed to be a debugger. [[7]](#7)",
                    "name": "Parent Process"
                },
                {
                    "definition": "The Process Environment Block (PEB) is a Windows data structure associated with each process that contains several fields, such as \"BeingDebugged,\" \"NtGlobalFlag,\" and \"IsDebugged\". Testing the value of this PEB field of a particular process can indicate whether the process is being debugged. Testing \"BeingDebugged\" is equivalent to using the kernel32!IsDebuggerPresent API call (see next method).",
                    "name": "Process Environment Block"
                },
                {
                    "definition": "[[7]](#7)",
                    "name": "Process Jobs"
                },
                {
                    "definition": "Process heaps are affected by debuggers. Malware can detect a debugger by checking heap header fields such as Flags (debugger present if value greater than 2) or ForceFlags (debugger present if value greater than 0).",
                    "name": "ProcessHeap"
                },
                {
                    "definition": "Malware may call RtlAdjustPrivilege to detect if a debugger is attached (or to prevent a debugger from attaching).",
                    "name": "RtlAdjustPrivilege"
                },
                {
                    "definition": "(Csrss.exe); Using the OpenProcess function on the csrss.exe process can detect a debugger. [[7]](#7)",
                    "name": "SeDebugPrivilege"
                },
                {
                    "definition": "(Protected Handle);",
                    "name": "SetHandleInformation"
                },
                {
                    "definition": "(INT3/0xCC)",
                    "name": "Software Breakpoints"
                },
                {
                    "definition": "Similar to the anti-exploitation method of the same name, malware may try to detect mucking with values on the stack.",
                    "name": "Stack Canary"
                },
                {
                    "definition": "Malware may access information in the Thread Information Block (TIB) for debug detection or process obfuscation detection. The TIB can be accessed as an offset of the segment register (e.g., fs:[20h]).",
                    "name": "TIB Aware"
                },
                {
                    "definition": "Malware may compare time between two points to detect unusual execution, such as the (relative) massive delays introduced by debugging.",
                    "name": "Timing/Delay Checks"
                },
                {
                    "definition": "[[7]](#7)",
                    "name": "TLS Callbacks"
                },
                {
                    "definition": "The UnhandledExceptionFilter function is called if no registered exception handlers exist, but it will not be reached if a debugger is present. See [[7]](#7) for details.",
                    "name": "UnhandledExceptionFilter"
                },
                {
                    "definition": "WudfIsAnyDebuggerPresent, WudfIsKernelDebuggerPresent, WudfIsUserDebuggerPresent",
                    "name": "WudfIsAnyDebuggerPresent"
                }
            ]
        }
    ]
}